<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx11.dtd">
<tmx version="1.1">
  <header creationtool="OmegaT" o-tmf="OmegaT TMX" adminlang="EN-US" datatype="plaintext" creationtoolversion="3.0.8_3" segtype="sentence" srclang="EN"/>
  <body>
<!-- Default translations -->
    <tu>
      <tuv lang="EN">
        <seg>![Code becomes a build, which is combined with config to create a release.](/images/release.png)</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T090913Z" creationid="nacyot" creationdate="20140518T090913Z">
        <seg>![Code becomes a build, which is combined with config to create a release.](/images/release.png)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>![One codebase maps to many deploys](/images/codebase-deploys.png)</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T141238Z" creationid="nacyot" creationdate="20140517T172139Z">
        <seg>![다수의 배포에 대한 하나의 코드베이스](/images/codebase-deploys.png)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>![Scale is expressed as running processes, workload diversity is expressed as process types.](/images/process-types.png)</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T173423Z" creationid="nacyot" creationdate="20140517T173423Z">
        <seg>![Scale is expressed as running processes, workload diversity is expressed as process types.](/images/process-types.png)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## I. Codebase
### One codebase tracked in revision control, many deploys</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T142241Z" creationid="nacyot" creationdate="20140517T171736Z">
        <seg>## 1. 코드베이스(Codebase)
### 버전 관리되는 하나의 코드베이스와 다수의 배포</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## II. Dependencies
### Explicitly declare and isolate dependencies</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T142306Z" creationid="nacyot" creationdate="20140511T152626Z">
        <seg>## 2. 의존성(Dependencies)
### 명시적인 의존성 선언과 분리</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## III. Config
### Store config in the environment</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T144125Z" creationid="nacyot" creationdate="20140517T163532Z">
        <seg>## 3. 설정(Config)
### 환경 변수에 설정 저장하기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## IV. Backing Services
### Treat backing services as attached resources</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T161049Z" creationid="nacyot" creationdate="20140517T161049Z">
        <seg>## 4. 백엔드 서비스
### 백엔드 서비스를 붙여둔 리소스로 다루기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## IX. Disposability
### Maximize robustness with fast startup and graceful shutdown</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T020830Z" creationid="nacyot" creationdate="20140518T020830Z">
        <seg>## 9. 일회용성
### 빠른 실행과 깔끔한 종료를 통한 견고성 최대화</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## V. Build, release, run
### Strictly separate build and run stages</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T171720Z" creationid="nacyot" creationdate="20140517T171708Z">
        <seg>## 5. 빌드, 릴리즈, 런
### 빌드와 실행 단계 엄격하게 구분하기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## VI. Processes
### Execute the app as one or more stateless processes</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T171442Z" creationid="nacyot" creationdate="20140517T171442Z">
        <seg>## 6. 프로세스
### 어플리케이션을 하나나 그 이상의 상태 없는 프로세스로 실행하기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## VII. Port binding
### Export services via port binding</seg>
      </tuv>
      <tuv lang="KO" changeid="hsin" changedate="20140517T062932Z" creationid="hsin" creationdate="20140517T062932Z">
        <seg>## 7. 포트 바인딩
### 포트 바인딩으로 서비스 공개하기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## VIII. Concurrency
### Scale out via the process model</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T172926Z" creationid="nacyot" creationdate="20140517T172923Z">
        <seg>## 8. 병행성
### 프로세스 모델을 스케일 아웃하기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## X. Dev/prod parity
### Keep development, staging, and production as similar as possible</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T174712Z" creationid="nacyot" creationdate="20140517T174652Z">
        <seg>## 10. 개발 / 프로덕션 일치
### 개발, 스테이징, 프로덕션을 최대한 일치시키기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## XI. Logs
### Treat logs as event streams</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140430T232640Z" creationid="nacyot" creationdate="20140430T232622Z">
        <seg>## 11. 로그
### 로그를 이벤트 스트림으로 다루기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## XII. Admin processes
### Run admin/management tasks as one-off processes</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T155750Z" creationid="nacyot" creationdate="20140517T155724Z">
        <seg>## 12. 관리 프로세스
### 관리 테스크를 한 번만 사용하는 프로세스로 실행하기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## [I.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140429T154428Z" creationid="nacyot" creationdate="20140429T154428Z">
        <seg>## [I.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## [I. Codebase](/codebase)
### One codebase tracked in revision control, many deploys</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T133356Z" creationid="nacyot" creationdate="20140429T154803Z">
        <seg>## [1. 코드베이스(Codebase)](/codebase)
### 버전 관리되는 하나의 코드베이스와 다수의 배포</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## [II. Dependencies](/dependencies)
### Explicitly declare and isolate dependencies</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T133443Z" creationid="nacyot" creationdate="20140429T154951Z">
        <seg>## [2. 의존성(Dependencies)](/dependencies)
### 명시적인 의존성 선언과 분리</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## [III. Config](/config)
### Store config in the environment</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T133505Z" creationid="nacyot" creationdate="20140429T155033Z">
        <seg>## [3. 설정(Config)](/config)
### 환경변수에 설정 저장하기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## [IV. Backing Services](/backing-services)
### Treat backing services as attached resources</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T133713Z" creationid="nacyot" creationdate="20140429T224330Z">
        <seg>## [4. 백엔드 서비스(Backing Services)](/backing-services)
### 백엔드 서비스를 붙여진 리소스(attched resources)로 다루기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## [IX. Disposability](/disposability)
### Maximize robustness with fast startup and graceful shutdown</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T133831Z" creationid="nacyot" creationdate="20140429T224545Z">
        <seg>## [9. 일회용성(Disposability)](/disposability)
### 빠른 실행과 깔금한 종료를 통해 견고성 최대화하기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## [V. Build, release, run](/build-release-run)
### Strictly separate build and run stages</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T133733Z" creationid="nacyot" creationdate="20140429T224352Z">
        <seg>## [5. 빌드(Build), 릴리스(Release), 실행(Run)](/build-release-run)
### 빌드와 실행 단계 엄격하게 분리하기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## [VI. Processes](/processes)
### Execute the app as one or more stateless processes</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T133707Z" creationid="nacyot" creationdate="20140429T224417Z">
        <seg>## [6. 프로세스(Processes)](/processes)
### 어플리케이션을 하나나 다수의 상태 없는 프로세스로 실행하기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## [VII. Port binding](/port-binding)
### Export services via port binding</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T133743Z" creationid="nacyot" creationdate="20140429T224435Z">
        <seg>## [7. 포트 바인딩(Port binding)](/port-binding)
### 포트 바인딩으로 서비스 공개하기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## [VIII. Concurrency](/concurrency)
### Scale out via the process model</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T133811Z" creationid="nacyot" creationdate="20140429T224500Z">
        <seg>## [8. 병행성(Concurrency)](/concurrency)
### 스케일 아웃을 위한 프로세스 모델</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## [X. Dev/prod parity](/dev-prod-parity)
### Keep development, staging, and production as similar as possible</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T134043Z" creationid="nacyot" creationdate="20140429T224617Z">
        <seg>## [10. 개발 / 배포 일치(Dev/Prod parity)](/dev-prod-parity)
### 개발, 스테이징, 프로덕션를 최대한 일치시키기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## [XI. Logs](/logs)
### Treat logs as event streams</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T134106Z" creationid="nacyot" creationdate="20140429T224644Z">
        <seg>## [11. 로그(Logs)](/logs)
### 로그를 이벤트 스트림으로 다루기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## [XII. Admin processes](/admin-processes)
### Run admin/management tasks as one-off processes</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T134201Z" creationid="nacyot" creationdate="20140429T224727Z">
        <seg>## [12. 관리 프로세스(Admin processes)](/admin-processes)
### 관리 작업을 일회용 프로세스로 실행하기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>* **Minimize divergence** between development and production, enabling **continuous deployment** for maximum agility;</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T135330Z" creationid="nacyot" creationdate="20140429T231656Z">
        <seg>* 개발 환경과 배포 환경의 **차이를 최소한 줄이고**, 에자일리티(agility)를 극대화하는 **계속적 배포(continuous deployment)**가 가능하다</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>* **The personnel gap**: Developers write code, ops engineers deploy it.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T005449Z" creationid="nacyot" creationdate="20140518T005449Z">
        <seg>* **사람 차이:** 프로그래머가 작성한 코드를 ops 엔지니어가 배포한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>* **The time gap:** A developer may work on code that takes days, weeks, or even months to go into production.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T005418Z" creationid="nacyot" creationdate="20140518T005418Z">
        <seg>* **시간 차이**: 프로그래머가 작업 중인 코드가 프로덕션 환경에 반영되기 까지는 수 일에서 수주, 심지어 수 개월이 걸린다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>* **The tools gap**: Developers may be using a stack like Nginx, SQLite, and OS X, while the production deploy uses Apache, MySQL, and Linux.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T005556Z" creationid="nacyot" creationdate="20140518T005549Z">
        <seg>* **도구 차이:** 개발은 주로 Nginx, SQLite, OS X와 같은 도구를 사용하지만 프로덕션 배포는 주로 Apache, MySQL, Linux를 사용한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>* Active alerting according to user-defined heuristics (such as an alert when the quantity of errors per minute exceeds a certain threshold).</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T105415Z" creationid="nacyot" creationdate="20140518T105415Z">
        <seg>* 사용자 정의 휴리스틱에 의존해 경고를 보냄(예를 들어 일 분동안 일정 이상의 에러가 발생하면 경고를 발생시킨다.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>* And can **scale up** without significant changes to tooling, architecture, or development practices.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T135324Z" creationid="nacyot" creationdate="20140429T231717Z">
        <seg>* 도구와 아키텍쳐를 비롯한 개발적 요소를 크게 바꾸지 않아도 스케일 아웃이 가능하다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>* Are suitable for **deployment** on modern **cloud platforms**, obviating the need for servers and systems administration;</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T135112Z" creationid="nacyot" creationdate="20140429T231553Z">
        <seg>* 현대적인 **클라우드 플랫폼**에서 배포하기에 적합하며, 서버와 시스템 관리를 피할 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>* Finding specific events in the past.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T105304Z" creationid="nacyot" creationdate="20140518T105304Z">
        <seg>* 과거에 발생한 특정한 이벤트를 찾을 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>* Have a **clean contract** with the underlying operating system, offering **maximum portability** between execution environments;</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T134956Z" creationid="nacyot" creationdate="20140429T230610Z">
        <seg>* 어플리케이션의 기반이 되는 운영체제에 대한 **의존관계를 명확하게 하고**, 실행 환경 간의 **이동성을 극대화한다.**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>* If there are multiple codebases, it's not an app -- it's a distributed system.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T141323Z" creationid="nacyot" creationdate="20140517T172226Z">
        <seg>* 코드베이스가 다수 존재한다면, 이는 단일 어플리케이션이 아니라 분산 시스템이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>* Large-scale graphing of trends (such as requests per minute).</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T105329Z" creationid="nacyot" creationdate="20140518T105329Z">
        <seg>* 큰 규모늬 경향을 그래프로 그릴 수 있다(예를 들어 분당 리퀘스트 수).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>* Make the personnel gap small: developers who wrote code are closely involved in deploying it and watching its behavior in production.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T005802Z" creationid="nacyot" creationdate="20140518T005802Z">
        <seg>* 사람 차이 줄이기: 코드를 작성한 개발자는 배포에 밀접하게 참여하면 프로덕션의 작동 상태를 확인한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>* Make the time gap small: a developer may write code and have it deployed hours or even just minutes later.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T005721Z" creationid="nacyot" creationdate="20140518T005721Z">
        <seg>* 시간 차이를 줄이기: 프로그래머가 작성한 코드는 몇 시간, 혹은 몇 분 안에 배포된다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>* Make the tools gap small: keep development and production as similar as possible.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T005822Z" creationid="nacyot" creationdate="20140518T005822Z">
        <seg>* 도구 차이 줄이기: 가능한 한 개발 환경과 프로덕션 환경의 시스템과 도구를 비슷하게구성한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>* Multiple apps sharing the same code is a violation of twelve-factor.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T172331Z" creationid="nacyot" creationdate="20140517T172331Z">
        <seg>* 하나의 코드를 공유하는 다수의 어플리케이션은 Twelve-Fator에 위배된다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>* Resource handles to the database, Memcached, and other [backing services](/backing-services)
* Credentials to external services such as Amazon S3 or Twitter
* Per-deploy values such as the canonical hostname for the deploy</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T164450Z" creationid="nacyot" creationdate="20140517T164353Z">
        <seg>* 데이터베이스, Memcached를 비롯한 [백엔드 서비스](/backing-services)에 대한 리소스 핸들
* Amazon S3와 Twitter와 같은 외부 서비스에 대한 인증 정보
* 배포된 호스트의 정규화(canonical)된 호스트 이름을 비롯해 배포환경별 값</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>* Running a console (also known as a [REPL](http://en.wikipedia.org/wiki/Read-eval-print_loop) shell) to run arbitrary code or inspect the app's models against the live database.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T160106Z" creationid="nacyot" creationdate="20140517T160106Z">
        <seg>* 임의의 코드를 실행하거나 데이터베이스에 대한 어플리케이션의 모델을 확인하기 위한 콘솔([REPL](http://en.wikipedia.org/wiki/Read-eval-print_loop)이라고도 한다)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>* Running database migrations (e.g. `manage.py syncdb` in Django, `rake db:migrate` in Rails).</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T160007Z" creationid="nacyot" creationdate="20140517T160007Z">
        <seg>* 데이터베이스 마이그레이션(예를 들면 Django의 `manage.py sincdb`나 레일스의 `rake db`)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>* Running one-time scripts committed into the app's repo (e.g. `php scripts/fix_bad_records.php`).</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T160244Z" creationid="nacyot" creationdate="20140517T160244Z">
        <seg>* 어플리케이션 저장소에 커밋된 한 번만 실행하기 위한 스크립트.(예를 들어 `php scripts/fix_bad_records.php`)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>* The *build stage* is a transform which converts a code repo into an executable bundle known as a *build*.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T090659Z" creationid="nacyot" creationdate="20140518T090530Z">
        <seg>* *빌드 스테이지*는 코드 저장소를 *빌드*라고 하는 실행가능한 번들로 변환된다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>* The *release stage* takes the build produced by the build stage and combines it with the deploy's current [config](/config).</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T090741Z" creationid="nacyot" creationdate="20140518T090741Z">
        <seg>* *릴리즈 단계*는 빌드 단계에서 생성된 빌드를 넘겨받아 현재 배포의 [설정](/config)과 결합한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>* The *run stage* (also known as "runtime") runs the app in the execution environment, by launching some set of the app's [processes](/processes) against a selected release.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T090910Z" creationid="nacyot" creationdate="20140518T090910Z">
        <seg>* *실행 단계*(혹은 런타임이라고도 하는)에서는 특정한 릴리스에 대해서 필요한 프로세스들을 기동하고 어플리케이션 실행환경에서 실행하고, </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>* Use **declarative** formats for setup automation, to minimize time and cost for new developers joining the project;</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T134834Z" creationid="nacyot" creationdate="20140429T230414Z">
        <seg>* **선언적인** 포맷을 사용한 환경설정 자동화로 새로운 프로그래머가 프로젝트에 참여하는데 드는 시간과 비용을 최소화한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>**A twelve-factor app never concerns itself with routing or storage of its output stream.**  It should not attempt to write to or manage logfiles.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T104700Z" creationid="nacyot" creationdate="20140518T104700Z">
        <seg>**Twelve Factor App은 어플리케이션의 출력 스트림을 보내는 곳이나 저장하는 위치에 대해 일체 간섭하지 않는다.** 어플리케이션은 로그를 작성하거나 로그파일을 관리하려고 해서는 안된다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>**A twelve-factor app never relies on implicit existence of system-wide packages.**  It declares all dependencies, completely and exactly, via a *dependency declaration* manifest.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T142658Z" creationid="nacyot" creationdate="20140511T153353Z">
        <seg>**Twelve-Factor App은 결코 암묵적으로 시스템 전체에 적용되는 패키지가 설치되어있다고 전제하지 않는다.** 모든 의존 관계는 *의존성 선언(dependency declaration)*을 통해서 완전하고 정확하게 선언된다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>**In the twelve-factor app, processes are a first class citizen.**  Processes in the twelve-factor app take strong cues from [the unix process model for running service daemons](http://adam.heroku.com/past/2011/5/9/applying_the_unix_process_model_to_web_apps/).</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T173554Z" creationid="nacyot" creationdate="20140517T173554Z">
        <seg>**Twelve-Factor App에서 프로세스는 일급 시민에 해당한다.** Twelve-Factor App에서 프로세스는 [서비스의 데몬을 실행하기 위핸 유닉스 프로세스 모델](http://adam.heroku.com/past/2011/5/9/applying_the_unix_process_model_to_web_apps/)에서 큰 영감을 받았다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>**The code for a twelve-factor app makes no distinction between local and third party services.**  To the app, both are attached resources, accessed via a URL or other locator/credentials stored in the [config](/config).</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T161627Z" creationid="nacyot" creationdate="20140517T161627Z">
        <seg>** Twelve-Factor App의 코드는 로컬 서비스와 써드 파티 서비스의 차이를 구분하지 않는다. 어플리케이션 입장에서 보자면 어느 쪽이건 붙여진 리소스로써 [설정](/config)에 저장된 URL이나 기타 로케터/인증 정보로 접근 가능하다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>**The twelve-factor app is completely self-contained** and does not rely on runtime injection of a webserver into the execution environment to create a web-facing service.</seg>
      </tuv>
      <tuv lang="KO" changeid="hsin" changedate="20140517T063416Z" creationid="hsin" creationdate="20140517T063416Z">
        <seg>**Twelve-Factor App은 철저히 스스로 완결되며** 웹에 공개되는 서비스를 만들기 위한 컨테이너가 실행환경에 웹서버 런타임을 주입하는 것에 의존하지 않는다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>**The twelve-factor app is designed for [continuous deployment](http://www.avc.com/a_vc/2011/02/continuous-deployment.html) by keeping the gap between development and production small.**  Looking at the three gaps described above:</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T005702Z" creationid="nacyot" creationdate="20140518T005551Z">
        <seg>**Twelve-Factor App은 [계속적 배포](http://www.avc.com/a_vc/2011/02/continuous-deployment.html)가 가능하도록 개발 환경과 프로덕션 간의 차이를 최소화 하도록 설계되었다. 위에서 살펴본 3가지 차이에 대새서 살펴보면 아래와 같다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>**The twelve-factor app stores config in *environment variables*** (often shortened to *env vars* or *env*).</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T170416Z" creationid="nacyot" creationdate="20140517T170416Z">
        <seg>**Twelve-Factor App은 설정을 *환경 변수(environment variables)*에 저장한다***(*env var*나 *env*라고 줄여말하기도 한다)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>**The twelve-factor app uses strict separation between the build, release, and run stages.**  For example, it is impossible to make changes to the code at runtime, since there is no way to propagate those changes back to the build stage.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T091027Z" creationid="nacyot" creationdate="20140518T091027Z">
        <seg>**Twelve-Fator App은 빌드, 릴리스, 실행 단계를 엄밀히 구분한다. 예를 들어 런타임에서 변경한 코드를 빌드 스테이지에 역전파할 수 있는 방법이 없기 때문에 이러한 변경은 애시당초에 불가능하다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>**The twelve-factor app's [processes](/processes) are *disposable*, meaning they can be started or stopped at a moment's notice.**  This facilitates fast elastic scaling, rapid deployment of [code](/codebase) or [config](/config) changes, and robustness of production deploys.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T021604Z" creationid="nacyot" creationdate="20140518T021604Z">
        <seg>**Twelve-Factor App의 [프로세스들](/processes)은 *폐기가능*하다. 즉 바로 실행하거나 종료할 수 있다.** 이러한 특징을 통해 빠르고 유연한 스케일링과 [코드](/codebase)와 [설정](/config)  변경에 따른 빠른 배포와 실뢰가능한 프로덕션 배포가 가능하다. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>**The twelve-factor developer resists the urge to use different backing services between development and production**, even when adapters theoretically abstract away any differences in backing services.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T010724Z" creationid="nacyot" creationdate="20140518T010724Z">
        <seg>비록 어댑터가 이론적으로 서로 다른 백엔드 서비스들의 완벽히 추상화해내고 있다고 할지라도, **Twelve-Factor App 개발자는 개발 환경과 프로덕션 환경 간에 다른 백엔드 서비스를 사용하고자 하는 마음을 견뎌내야한다. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>**Twelve-factor processes are stateless and [share-nothing](http://en.wikipedia.org/wiki/Shared_nothing_architecture).**  Any data that needs to persist must be stored in a stateful [backing service](/backing-services), typically a database.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T121840Z" creationid="nacyot" creationdate="20140518T121840Z">
        <seg>**Twelve-Factor의 프로세스들은 상태가 없으며 [share-nothing](http://en.wikipedia.org/wiki/Shared_nothing_architecture)이다.** 장기적으로 저장되어야하는 모든 데이터는 데이터베이스와 같이 상태를 가지는 [백엔드 서비스](/backing-services)에 저장되어야한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>*Logs* provide visibility into the behavior of a running app.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140430T235621Z" creationid="nacyot" creationdate="20140430T232705Z">
        <seg>*Logs*는 실행중인 어플리케이션에서 일어나는 일들을 보여준다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>&lt;img src="/images/attached-resources.png" class="full" alt="A production deploy attached to four backing services." /&gt;</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T163331Z" creationid="nacyot" creationdate="20140517T163331Z">
        <seg>&lt;img src="/images/attached-resources.png" class="full" alt="A production deploy attached to four backing services." /&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;Traditional app&lt;/th&gt;
    &lt;th&gt;Twelve-factor app&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;th&gt;Time between deploys&lt;/th&gt;
    &lt;td&gt;Weeks&lt;/td&gt;
    &lt;td&gt;Hours&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;th&gt;Code authors vs code deployers&lt;/th&gt;
    &lt;td&gt;Different people&lt;/td&gt;
    &lt;td&gt;Same people&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;th&gt;Dev vs production environments&lt;/th&gt;
    &lt;td&gt;Divergent&lt;/td&gt;
    &lt;td&gt;As similar as possible&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T010005Z" creationid="nacyot" creationdate="20140518T005833Z">
        <seg>&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;기존의 어플리케이션&lt;/th&gt;
    &lt;th&gt;Twelve-Factor App&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;th&gt;배포 간격&lt;/th&gt;
    &lt;td&gt;수 주&lt;/td&gt;
    &lt;td&gt;몇 시간&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;th&gt;코드 작성상 vs 코드 배포자&lt;/th&gt;
    &lt;td&gt;다른 사람&lt;/td&gt;
    &lt;td&gt;같은 사람&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;th&gt;개발 환경 vs 프로덕션 환경&lt;/th&gt;
    &lt;td&gt;다름&lt;/td&gt;
    &lt;td&gt;가능한 비슷하게 구성&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Type&lt;/th&gt;
    &lt;th&gt;Language&lt;/th&gt;
    &lt;th&gt;Library&lt;/th&gt;
    &lt;th&gt;Adapters&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Database&lt;/td&gt;
    &lt;td&gt;Ruby/Rails&lt;/td&gt;
    &lt;td&gt;ActiveRecord&lt;/td&gt;
    &lt;td&gt;MySQL, PostgreSQL, SQLite&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Queue&lt;/td&gt;
    &lt;td&gt;Python/Django&lt;/td&gt;
    &lt;td&gt;Celery&lt;/td&gt;
    &lt;td&gt;RabbitMQ, Beanstalkd, Redis&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Cache&lt;/td&gt;
    &lt;td&gt;Ruby/Rails&lt;/td&gt;
    &lt;td&gt;ActiveSupport::Cache&lt;/td&gt;
    &lt;td&gt;Memory, filesystem, Memcached&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T010334Z" creationid="nacyot" creationdate="20140518T010221Z">
        <seg>&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;분류&lt;/th&gt;
    &lt;th&gt;언어&lt;/th&gt;
    &lt;th&gt;라이브러리&lt;/th&gt;
    &lt;th&gt;어댑터&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;데이터베이스&lt;/td&gt;
    &lt;td&gt;루비 온 레일스&lt;/td&gt;
    &lt;td&gt;Active Record&lt;/td&gt;
    &lt;td&gt;MySQL, PostgreSQL, SQLite&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;큐&lt;/td&gt;
    &lt;td&gt;파이썬 / Django&lt;/td&gt;
    &lt;td&gt;Celery&lt;/td&gt;
    &lt;td&gt;RabbitMQ, Beanstalkd, Redis&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;캐시&lt;/td&gt;
    &lt;td&gt;루비 온 레일스&lt;/td&gt;
    &lt;td&gt;ActiveSupport::Cache&lt;/td&gt;
    &lt;td&gt;메모리, 파일, Memcached&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>==============================</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T170934Z" creationid="nacyot" creationdate="20140517T170934Z">
        <seg>==============================</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A *backing service* is any service the app consumes over the network as part of its normal operation.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T161124Z" creationid="nacyot" creationdate="20140517T161124Z">
        <seg>백엔드 서비스란 어플리케이션이 실행되는 가운데 네트워크를 통해서 사용될 수 있는 모든 서비스를 일컫는다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A *codebase* is any single repo (in a centralized revision control system like Subversion), or any set of repos who share a root commit (in a decentralized revision control system like Git).</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T141230Z" creationid="nacyot" creationdate="20140517T172123Z">
        <seg>*코드베이스*란 Subversion과 같은 중앙 관리형 버전 관리 시스템에서 하나의 저장소나, Git과 같은 분산형 버전 관리 시스템에서 루트 커밋을 공유하는 다수의 저장소를 일컫는다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A *deploy* is a running instance of the app.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T141655Z" creationid="nacyot" creationdate="20140517T172523Z">
        <seg>*배포(deploy)*란 어플리케이션의 인스턴스에 해당한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A [codebase](/codebase) is transformed into a (non-development) deploy through three stages:</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T090448Z" creationid="nacyot" creationdate="20140518T090448Z">
        <seg>[코드베이스](/codebase)는 3단계에 걸쳐서 (개발환경에 해당하지 않는) 배포로 변환된다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A [deploy](/codebase) of the twelve-factor app should be able to swap out a local MySQL database with one managed by a third party (such as [Amazon RDS](http://aws.amazon.com/rds/)) without any changes to the app's code.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T162950Z" creationid="nacyot" creationdate="20140517T162937Z">
        <seg>Twelve-Factor App의 [배포](/codebase)는 어플리케이션 코드의 변경 없이도 로컬에서 관리되는 Mysql 데이터베이스와 써드 파티에서 관리되는 서비스(예를 들어 [Amazon RDS](http://aws.amazon.com/rds/))를 변경할 수 있어야합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A copy of the revision tracking database is known as a *code repository*, often shortened to *code repo* or just *repo*.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T141055Z" creationid="nacyot" creationdate="20140517T171936Z">
        <seg>버전 관리의 이력 정보를 담고 있는 데이터베이스는 *코드 저장소(code repository)*라고 불린다. 이를 줄여서 *code repo*나 *repo*라고 부르기도 한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A litmus test for whether an app has all config correctly factored out of the code is whether the codebase could be made open source at any moment, without compromising any credentials.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T164744Z" creationid="nacyot" creationdate="20140517T164741Z">
        <seg>어플리케이션으로부터 설정이 적절하게 분리되어있는 여부를 테스트할 수 있는 간단한 방법은 어떠한 인증 정보도 포함하지 않고 지금 당장 코드를 오픈소스화 가능한지 여부에 달려있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A recommended approach is use of a robust queueing backend, such as Beanstalkd, that returns jobs to the queue when clients disconnect or time out.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T023746Z" creationid="nacyot" creationdate="20140518T023746Z">
        <seg>추천되는 방법은 먼저 Beanstalkd와 같은 견고한 큐잉 백엔드 시스템을 사용해야하며 클라이언트의 접속이 끊기거나 타임아웃됐을 때 잡을 다시 큐로 돌려주어야한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A twelve-factor app is always tracked in a version control system, such as [Git](http://git-scm.com/), [Mercurial](http://mercurial.selenic.com/), or [Subversion](http://subversion.apache.org/).</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T140923Z" creationid="nacyot" creationdate="20140517T171823Z">
        <seg>Twelve-Factor App은 항상 [Git](http://git-scm.com/), [Mercurial](http://mercurial.selenic.com/), [Subversion](http://subversion.apache.org/)과 같은 버전 관리 시스템을 사용한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A twelve-factor app prefers to do this compiling during the [build stage](/build-release-run), such as the [Rails asset pipeline](http://ryanbigg.com/guides/asset_pipeline.html), rather than at runtime.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T124356Z" creationid="nacyot" creationdate="20140518T124356Z">
        <seg>Twelve-Factor App은 컴파일을 실행 중에 하기보다는 [Rails 에셋 파이프라인](http://ryanbigg.com/guides/asset_pipeline.html)과 같이 [빌드 단계](/build-release-run)에서 실행한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Adapters to different backing services are still useful, because they make porting to new backing services relatively painless.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T020441Z" creationid="nacyot" creationdate="20140518T020441Z">
        <seg>서로 다른 백엔드 서비스를 사용할 수 있게 해주는 어댑터는 여전히 유용하다. 이러한 어댑터는 새로운 백엔드 서비스를 사용하는 데 드는 노력을 줄여준다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Additionally, every developer has a copy of the app running in their local development environment, each of which also qualifies as a deploy.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T141822Z" creationid="nacyot" creationdate="20140517T172649Z">
        <seg>한편 어플리케이션 개발에 참여하는 프로그래머들은 각자의 로컬 개발 환경에서 실행되는 어플리케이션 복사본을 가지고 있는데, 이 또한 하나의 배포라고 볼 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Admin code must ship with application code to avoid synchronization issues.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T160452Z" creationid="nacyot" creationdate="20140517T160452Z">
        <seg>관리용 코드는 동기 문제를 피하기 위해 어플리케이션과 함께 배포되어야한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Alternatively, declarative provisioning tools such as [Chef](http://www.opscode.com/chef/) and [Puppet](http://docs.puppetlabs.com/) combined with light-weight virtual environments such as [Vagrant](http://vagrantup.com/) allow developers to run local environments which closely approximate production environments.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T015423Z" creationid="nacyot" creationdate="20140518T015423Z">
        <seg>아니면 [Chef](http://www.opscode.com/chef/)와 [Puppet](http://docs.puppetlabs.com/)과 같은 선언적 프로비저닝과 함께 [Vagrant](http://vagrantup.com/)를 사용하면 프로그래머의 개발환경을 프로덕션 환경에 거의 일치시킬 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>An app's *config* is everything that is likely to vary between [deploys](/codebase) (staging, production, developer environments, etc).</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T144205Z" creationid="nacyot" creationdate="20140517T163533Z">
        <seg>어플리케이션의 *설정*은 개발, 스테이징, 프로덕션등 다양한 [배포](/codebase) 환경에 대해서 유일한 차이에 해당한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Another approach to config is the use of config files which are not checked into revision control, such as `config/database.yml` in Rails.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T165951Z" creationid="nacyot" creationdate="20140517T165951Z">
        <seg>설정에 대한 또 다른 접근 방법은 레일스의 `config/database.yml`와 같은 파일을 버전 관리 시스템에 체크 포함시키지 않는 것이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Another aspect of config management is grouping.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T170638Z" creationid="nacyot" creationdate="20140517T170638Z">
        <seg>설정 관리에서 또 하나 염두해야할 부분은 그룹핑이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Any change must create a new release.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T091443Z" creationid="nacyot" creationdate="20140518T091443Z">
        <seg>모든 변화는 새로운 릴리스를 통해서 만들어져야한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Any computer program, once run, is represented by one or more processes.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T173008Z" creationid="nacyot" creationdate="20140517T173003Z">
        <seg>모든 컴퓨터 프로그램은 한 번 실행되면 하나나 그 이상의 프로세스로서 나타난다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Any developer building applications which run as a service.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T140736Z" creationid="nacyot" creationdate="20140517T170953Z">
        <seg>서비스로서 작동하는 어플리케이션을 개발하는 모든 프로그래머</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Apps sometimes store config as constants in the code.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T164508Z" creationid="nacyot" creationdate="20140517T164508Z">
        <seg>어플리케이션에는 때때로 코드에 환경 설정을 저장한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>As the project grows further, developers may add their own special environments like `joes-staging`, resulting in a combinatorial explosion of config which makes managing deploys of the app very brittle.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T125403Z" creationid="nacyot" creationdate="20140518T125403Z">
        <seg>더욱 프로젝트가 확대되면 프로그래머는 `joes-staging`와 같은 자신만의 환경을 추가하게 된다. 결과정으로 설정이 설정은 조합에 따라서 폭발적으로 늘어나고 어플리케이션 배포 고나리는 불안정하게 된다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Asset packagers (such as [Jammit](http://documentcloud.github.com/jammit/) or [django-assetpackager](http://code.google.com/p/django-assetpackager/)) use the filesystem as a cache for compiled assets.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T124259Z" creationid="nacyot" creationdate="20140518T124259Z">
        <seg>([Jammit](http://documentcloud.github.com/jammit/))이나 [django-assetpackager](http://code.google.com/p/django-assetpackager/)와 같은 에셋 패키저는 컴파일된 에셋을 캐시하기 위해서 파일 시스템을 사용한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Background
==========</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140430T231835Z" creationid="nacyot" creationdate="20140430T231835Z">
        <seg>배경
==========</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Backing services like the database are traditionally managed by the same systems administrators as the app's runtime deploy.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T161355Z" creationid="nacyot" creationdate="20140517T161355Z">
        <seg>과거에 데이터베이스와 같은 백엔드 서비스는 배포된 어플리케이션과 같은 시스템 관리자에 의해서 관리되었다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Builds are initiated by the app's developers whenever new code is deployed.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T091512Z" creationid="nacyot" creationdate="20140518T091512Z">
        <seg>빌드 스테이지는 새로운 코드가 배포되는 시점에 반드시 프로그래머에 의해 시작된다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>But all deploys of the app (developer environments, staging, production) should be using the same type and version of each of the backing services.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T020757Z" creationid="nacyot" creationdate="20140518T020757Z">
        <seg>하지만 개발 환경, 스테이징, 프로덕션과 같은 모든 종류의 배포에서 같은 종류, 같은 버전의 백엔드 서비스를 사용해야한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>But an individual VM can only grow so large (vertical scale), so the application must also be able to span multiple processes running on multiple physical machines.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T174122Z" creationid="nacyot" creationdate="20140517T174122Z">
        <seg>하지만 각각의 VM은 어느 정도 이상 커지지(Vertical scale) 않기 때문에 어플리케이션은 복수의 물리 머신에서 동작하는 복수의 프로세스로 확대되지 않으면 안 된다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>But they all share the same codebase, thus making them identifiable as different deploys of the same app.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T142210Z" creationid="nacyot" creationdate="20140517T172859Z">
        <seg>하지만 로컬과 스테이징, 프로덕션은 모두 같은 코드베이스를 공유하고 있으며, 따라서 같은 어플리케이션의 다른 배포라고 할 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Config varies substantially across deploys, code does not.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T164610Z" creationid="nacyot" creationdate="20140517T164610Z">
        <seg>설정은 배포 환경에 따라서 달라지지만 코드는 그렇지 않다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Contributions from: James Lindenbaum, Mark McGranaghan, Chris Stolt, Ryan
Daigle, Mark Imbriaco, Keith Rarick, Will Leinweber, Jesper Jørgensen, James
Ward, Adam Seligman, Phil Hagelberg, Jon Mountjoy, Matthew Turland, Daniel
Jomphe, Mattt Thompson, Anand Narasimhan, Lucas Fais, Pete Hodgson</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T170905Z" creationid="nacyot" creationdate="20140517T170905Z">
        <seg>Contributions from: James Lindenbaum, Mark McGranaghan, Chris Stolt, Ryan
Daigle, Mark Imbriaco, Keith Rarick, Will Leinweber, Jesper Jørgensen, James
Ward, Adam Seligman, Phil Hagelberg, Jon Mountjoy, Matthew Turland, Daniel
Jomphe, Mattt Thompson, Anand Narasimhan, Lucas Fais, Pete Hodgson</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Created by Adam Wiggins</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T170904Z" creationid="nacyot" creationdate="20140517T170904Z">
        <seg>Created by Adam Wiggins</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Deployment tools typically offer release management tools, most notably the ability to roll back to a previous release.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T091106Z" creationid="nacyot" creationdate="20140518T091106Z">
        <seg>배포 툴은 일반적으로 릴리스 관리 툴을 제공하며 이러한 툴에서는 일반적으로 이전 릴리스로 되돌리는 롤백 기능을 제공한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Developers sometimes find great appeal in using a lightweight backing service in their local environments, while a more serious and robust backing service will be used in production.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T010438Z" creationid="nacyot" creationdate="20140518T010438Z">
        <seg>일반적으로 프로덕션 환경에서는 더 신뢰가 있는 백엔드 서비스가 사용되지만ㅡ 개발자들은 자신의 로컬 개발 환경에서는 좀 더 가벼운 백엔드 서비스를 찾기도 한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Development
-----------</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T170902Z" creationid="nacyot" creationdate="20140517T170902Z">
        <seg>Development
-----------</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Differences between backing services mean that tiny incompatibilities crop up, causing code that worked and passed tests in development or staging to fail in production.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T010858Z" creationid="nacyot" creationdate="20140518T010858Z">
        <seg>백엔드 서비스가 다르다는 얘기는 아주 작은 비호환성을 가지고 있으며, 개발 환경과 스테이징에서 테스트까지 통과하는 코드가 프로덕션 환경에서는 제대로 작동하지 않을 가능성을 가지고 있다는 의미를 지닌다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>During local development, the developer will view this stream in the foreground of their terminal to observe the app's behavior.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T104818Z" creationid="nacyot" creationdate="20140518T104818Z">
        <seg>로컬에서 개발중일 때는 개발자가 이 출력을 터미널의 포레그라운드에서 확인하면서 어플리케이션의 동작을 확인할 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Each component in a distributed system is an app, and each can individually comply with twelve-factor.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T141442Z" creationid="nacyot" creationdate="20140517T172310Z">
        <seg>물론 분산 시스템에서도 구성 요소가 되는 각각의 컴포넌트는 하나의 어플리케이션이며, 따라서 Twelve-Factor를 따를 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Each distinct backing service is a *resource*.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T163104Z" creationid="nacyot" creationdate="20140517T163104Z">
        <seg>각각의 벡엔드 서비스는 *리소스*입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Either way, a twelve-factor app is architected to handle unexpected, non-graceful terminations.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T090318Z" creationid="nacyot" creationdate="20140518T090318Z">
        <seg>어느 쪽이건 Twelve-Factor App은 예상되지 않은 정상적이지 않은 종료에 대응해야한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Env vars are easy to change between deploys without changing any code;</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T170502Z" creationid="nacyot" creationdate="20140517T170454Z">
        <seg>환경변수는 코드를 변경하지 않고도 쉽게 변경할 수 있다는 장점이 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Even C has [Autoconf](http://www.gnu.org/s/autoconf/) for dependency declaration, and static linking can provide dependency isolation.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T143251Z" creationid="nacyot" creationdate="20140511T154010Z">
        <seg>심지어 C에서도 [Autoconf](http://www.gnu.org/s/autoconf/)를 통해 의존성 선언을 할 수 있으며, 정적 링크를 이용해 의존성 분리를 실현할 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Even when running only one process, a restart (triggered by code deploy, config change, or the execution environment relocating the process to a different physical location) will usually wipe out all local (e.g., memory and filesystem) state.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T122211Z" creationid="nacyot" creationdate="20140518T122211Z">
        <seg>하나의 프로세스만 사용하는 경우에도 프로세스를 재실행하면 모든 국소적인 상태(메모리나 파일 시스템 등)은 사라져 버릴 수 있다. 프로세스가 재실행되는 이유는 코드 배포, 설정 변경, 프로세스를 다른 물리 머신의 배치시키는 등이 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Every release should always have a unique release ID, such as a timestamp of the release (such as `2011-04-06-20:32:17`) or an incrementing number (such as `v100`).</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T091332Z" creationid="nacyot" creationdate="20140518T091332Z">
        <seg>모든 릴리스는 자기 고유의 릴리스 ID를 가져야한다. 이러한 릴리스 아이디로는 릴리스 시점의 타임스탬프(예를 들어 `2011-04-06-20:32:17`)나 자동으로 증가하는 번호(예를 들어 v100)이 사용될 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Examples include SMTP services (such as [Postmark](http://postmarkapp.com/)), metrics-gathering services (such as [New Relic](http://newrelic.com/) or [Loggly](http://www.loggly.com/)), binary asset services (such as [Amazon S3](http://aws.amazon.com/s3/)), and even API-accessible consumer services (such as [Twitter](http://dev.twitter.com/), [Google Maps](http://code.google.com/apis/maps/index.html), or [Last.fm](http://www.last.fm/api)).</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T131116Z" creationid="nacyot" creationdate="20140518T131116Z">
        <seg>예를 들어 [Postmark](http://postmarkapp.com/)과 같은 SMTP 서비스, [New Relic](http://newrelic.com)이나 [Loggly](http://www.loggly.com)과 같은 메트릭스 수집 서비스, [Amazon S3](http://aws.amazon.com/s3)와 같은 바이너리 에셋 서비스, [Twitter](http://dev.twitter.com)이나 [Google Maps](http://code.google.com/apis/maps/index.html)이나 [Last.fm](http://www.last.fm/api)와 같은 API로 접근가능한 서비스들이 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Examples include [ejabberd](http://www.ejabberd.im/) (speaking [XMPP](http://xmpp.org/)), and [Redis](http://redis.io/) (speaking the [Redis protocol](http://redis.io/topics/protocol)).</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T121326Z" creationid="nacyot" creationdate="20140518T121326Z">
        <seg>예를 들어 [ejabberd](http://www.ejabberd.im/)([XMPP](http://xmpp.org/)) [Redis(speaking [XMPP](http://xmpp.org/)([Redis 프로토콜](http://redis.io/))이 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Examples include datastores (such as [MySQL](http://dev.mysql.com/) or [CouchDB](http://couchdb.apache.org/)), messaging/queueing systems (such as [RabbitMQ](http://www.rabbitmq.com/) or [Beanstalkd](http://kr.github.com/beanstalkd/)), SMTP services for outbound email (such as [Postfix](http://www.postfix.org/)), and caching systems (such as [Memcached](http://memcached.org/)).</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T130758Z" creationid="nacyot" creationdate="20140518T130758Z">
        <seg>예를 들어 [Mysql](http://dev.mysql.com/)이나 [CouchDB](http://couchdb.apache.org)와 같은 데이터베이스, [RabbitMQ](http://www.rabbitmq.com)이나 [Beanstalkd](http://kr.github.com/beanstalkd/)와 같은 메시지/큐 시스템, [Postfix](http://www.postfix.org)와 같은 메일 송신을 위한 SMTP 서비스, [Memcached](http://memcached.org)와 같은 캐시 시스템이 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Examples include shelling out to ImageMagick or `curl`.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T143926Z" creationid="nacyot" creationdate="20140511T154946Z">
        <seg>어플리케이션에서는 이미지 편집을 위해 ImageMagick을 사용하거나 웹 페이지 접근을 위해 `curl`을 사용하기도 한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For a web process, graceful shutdown is achieved by ceasing to listen on the service port (thereby refusing any new requests), allowing any current requests to finish, and then exiting.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T022755Z" creationid="nacyot" creationdate="20140518T022755Z">
        <seg>Web 프로세스는 서비스 포트로 리슨을 중단하고 (따라서 새로운 요청을 받지 않고) 처리중인 요청이 처리될 때까지 기다린 후 종료된다. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For a worker process, graceful shutdown is achieved by returning the current job to the work queue.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T023154Z" creationid="nacyot" creationdate="20140518T023154Z">
        <seg>워커 프로세스는 처리중인 잡을 워크 ㅋ에 되돌리는 것으로 정상적인 종료를 실현할 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For example, HTTP requests may be handled by a web process, and long-running background tasks handled by a worker process.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T173752Z" creationid="nacyot" creationdate="20140517T173752Z">
        <seg>예를 들어 HTTP 요청은 웹 프로세스가 처리하며 시간이 걸리는 백그라운드 작업은 워커 프로세스를 통해 처리한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For example, PHP apps might run as a module inside [Apache HTTPD](http://httpd.apache.org/), or Java apps might run inside [Tomcat](http://tomcat.apache.org/).</seg>
      </tuv>
      <tuv lang="KO" changeid="hsin" changedate="20140517T063204Z" creationid="hsin" creationdate="20140517T063103Z">
        <seg>예를 들어 PHP 어플리케이션은 [Apache HTTPD](httpd.apache.org/) 내부의 모듈로 실행되기도 하며, Java 어플리케이션은 [Tomcat](http://tomcat.apache.org/) 안에서 실행되기도 한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For example, PHP processes run as child processes of Apache, started on demand as needed by request volume.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T173058Z" creationid="nacyot" creationdate="20140517T173058Z">
        <seg>예를 들어 PHP 프로세스는 Apache의 자식 프로세스로 실행되며 리퀘스트 양에 따라서 프로세스가 실행된다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For example, [Gem Bundler](http://gembundler.com/) for Ruby offers the `Gemfile` manifest format for dependency declaration and `bundle exec` for dependency isolation.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T143211Z" creationid="nacyot" creationdate="20140511T153622Z">
        <seg>예를 들어 루비에서 사용되는 [Gem Bundler](http://gembundler.com/)는 `Gemfile` 형식을 의존성 정의에 사용하며 `bundle exec`를 통해서 의존성을 분리한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For example, a MySQL database is a resource;</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T163113Z" creationid="nacyot" creationdate="20140517T163113Z">
        <seg>예를 들어 Mysql 데이터베이스는 하나의 리소스입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For example, a developer has some commits not yet deployed to staging;</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T142044Z" creationid="nacyot" creationdate="20140517T172814Z">
        <seg>예를 들어 프로그래머 로컬 환경에는 스테이징 환경에 아직 배포되지 않은 커밋이 포함되어있을 수도 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For example, downloading a large file, operating on it, and storing the results of the operation in the database.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T121944Z" creationid="nacyot" creationdate="20140518T121944Z">
        <seg>예를 들어 큰 파일을 다운로드하고, 이 파일을 처리해서 결과를 데이터베이스에 저장하는 일련의 처리에 대해서 파일 시스템을 캐시로 이용해도 된다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For example, if the Ruby web process uses the command `bundle exec thin start`, then a database migration should use `bundle exec rake db:migrate`.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T160555Z" creationid="nacyot" creationdate="20140517T160555Z">
        <seg>예를 들어 루비 웹 프로세스가 `bundle exec thin start`로 실행된다면 데이터베이스 마이그레이션은 `bundle exec rake db:migrate` 명령어를 통해서 실행되어야한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For example, if the app's database is misbehaving due to a hardware issue, the app's administrator might spin up a new database server restored from a recent backup.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T163429Z" creationid="nacyot" creationdate="20140517T163429Z">
        <seg>예를 들어 하드웨어 문제로 어플리케이션 동작이 이상하다면 어플리케이션 관리자는 백업으로부터 새로운 데이터베이스 서버를 실행시킬 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For example, on [RabbitMQ](http://www.rabbitmq.com/) the worker can send a [`NACK`](http://www.rabbitmq.com/amqp-0-9-1-quickref.html#basic.nack);</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T023219Z" creationid="nacyot" creationdate="20140518T023219Z">
        <seg>예를 들어 [RabbitMQ](http://www.rabbitmq.com/) 워커는 [`NACK`](http://www.rabbitmq.com/amqp-0-9-1-quickref.html#basic.nack)을 보낼 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For example, the [Capistrano](https://github.com/capistrano/capistrano/wiki) deployment tool stores releases in a subdirectory named `releases`, where the current release is a symlink to the current release directory.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T091203Z" creationid="nacyot" creationdate="20140518T091203Z">
        <seg>예를 들어 [Capistrano](https://github.com/capistrano/capistrano/wiki) 배포 툴은 릴리스를 `releases`라는 서브 디렉토리 안에 저장한다. 이 디렉토리 아래서 현재 릴리스는 현재 릴리스 디렉토리를 가리키는 심볼릭 링크이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For example, the build command for Ruby/Bundler is `bundle install`, while for Clojure/[Leiningen](https://github.com/technomancy/leiningen#readme) it is `lein deps`.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T143701Z" creationid="nacyot" creationdate="20140511T154711Z">
        <seg>예를 들어 루비 번들러의 빌드 명령어는  `bundle install`이고, 클로저(Clojure) Leiningen에서는 `lein deps` 명령어를 실행하면 된다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For example, using SQLite locally and PostgreSQL in production;</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T010513Z" creationid="nacyot" creationdate="20140518T010513Z">
        <seg>예를 들어 프로덕션 환경에서는 PostgreSQL을 사용하지만 개발에는 SQLite를 사용한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Further, these formats tend to be language- or framework-specific.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T170318Z" creationid="nacyot" creationdate="20140517T170318Z">
        <seg>더욱이 이러한 포맷은 언어나 프레임워크에 지나치게 의존적일 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Furthermore, it uses a *dependency isolation* tool during execution to ensure that no implicit dependencies "leak in" from the surrounding system.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T143013Z" creationid="nacyot" creationdate="20140511T153428Z">
        <seg>나아가 어플리케이션 실행 중에는 *의존성 분리(dependency isolation)* 툴을 사용해 어플리케이션에서만 사용되는 의존 라이브러리가 암묵적으로 외부에 공개되지 않도록 해야한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>HTTP is not the only service that can be exported by port binding.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T111605Z" creationid="nacyot" creationdate="20140518T111605Z">
        <seg>포트 바인딩을 통해 공개되는 서비스는 HTTP뿐이 아니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Historically, there have been substantial gaps between development (a developer making live edits to a local [deploy](/codebase) of the app) and production (a running deploy of the app accessed by end users).</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T005328Z" creationid="nacyot" creationdate="20140518T005322Z">
        <seg>역사적으로 개발 환경(개발자가 직접 변경할 수 있는 어플리케이션의 로컬 배포) 프로덕션 환경(사용자가 어플리케이션을 사용할 수 있는 배포) 간에는 큰 차이가 있었다. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Ideally, a process takes a few seconds from the time the launch command is executed until the process is up and ready to receive requests or jobs.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T022136Z" creationid="nacyot" creationdate="20140518T022136Z">
        <seg>이상적으로 하나의 프로세스는 실행 명령어로부터 몇 초 안에 요청이나 다른 일을 처리할 준비가 되어야한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If the app needs to shell out to a system tool, that tool should be vendored into the app.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T144104Z" creationid="nacyot" creationdate="20140511T155146Z">
        <seg>어플리케이션에서 외부 프로그램을 사용하는 경우엔 그 프로그램을 어플리케이션에 포함해야한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Implicit in this model is that HTTP requests are short (no more than a few seconds), or in the case of long polling, the client should seamlessly attempt to reconnect when the connection is lost.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T022905Z" creationid="nacyot" creationdate="20140518T022905Z">
        <seg>이러한 모델은 HTTP 요청이 짧다고 가정하고 있으며(길어야 몇 초) 롱 풀링을 하는 경우 클라이언트는 접속이 종료될 때 지속적으로 재접속을 시도한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Implicit in this model is that all jobs are [reentrant](http://en.wikipedia.org/wiki/Reentrant_%28subroutine%29), which typically is achieved by wrapping the results in a transaction, or making the operation [idempotent](http://en.wikipedia.org/wiki/Idempotence).</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T023456Z" creationid="nacyot" creationdate="20140518T023456Z">
        <seg>이러한 모델은 암묵적으로 모든 잡이 다시 큐로 되돌아 올 수 있다고 가정하고 있다. 다시 돌아올 수 있다는 것은 일반적으로 결과를 트랜젝션으로 감싸거나 처리를 멱등으로 다룬다는 것을 의미한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In a local deploy, developers invoke one-off admin processes by a direct shell command inside the app's checkout directory.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T160957Z" creationid="nacyot" creationdate="20140517T160957Z">
        <seg>로컬 배포에서 개발자는 한 번만 사용하는 관리 프로세스를 어플리케이션을 체크아웃한 디렉토리 안에서 쉘 명령어로서 직접 실행한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In a local development environment, the developer visits a service URL like `http://localhost:5000/` to access the service exported by their app.</seg>
      </tuv>
      <tuv lang="KO" changeid="hsin" changedate="20140517T070710Z" creationid="hsin" creationdate="20140517T063952Z">
        <seg>로컬 개발환경에서 개발자는 어플리케이션에 의해 공개된 서비스에 접근하기 위해 `http://localhost:5000`와 같은 서비스 URL에 접근합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In a production deploy, developers can use ssh or other remote command execution mechanism provided by that deploy's execution environment to run such a process.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T160959Z" creationid="nacyot" creationdate="20140517T160959Z">
        <seg>실제 배포 과정에서 개발자는 SSH나 배포 환경이 제공하는 다른 리모트 커맨드 실행 방법을 사용해 해당하는 프로세스를 실행한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In a twelve-factor app, env vars are granular controls, each fully orthogonal to other env vars.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T125606Z" creationid="nacyot" creationdate="20140518T125606Z">
        <seg>Twelve-Factor App은 환경변수는 쌀알 정도의 세밀한 관리를 하며 각각의 환경변수는 서로에 대해 직교한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In addition to these locally-managed services, the app may also have services provided and managed by third parties.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T161430Z" creationid="nacyot" creationdate="20140517T161430Z">
        <seg>또한 이러한 로컬에서 관리되는 서비스와 더불어 서드 파티에서 제공하고 관리되는 서비스도 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In both cases, only the resource handle in the config needs to change.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T163041Z" creationid="nacyot" creationdate="20140517T163041Z">
        <seg>두 사례 모두 변경이 필요한 부분은 설정의 리소스 핸들 부분입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In both cases, the running process(es) are only minimally visible to the developers of the app.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T173419Z" creationid="nacyot" creationdate="20140517T173419Z">
        <seg>어느 쪽이건 실행되는 프로세스는 어플리케이션 개발자에게는 거의 감추어져있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In deployment, a routing layer handles routing requests from a public-facing hostname to the port-bound web processes.</seg>
      </tuv>
      <tuv lang="KO" changeid="hsin" changedate="20140517T070838Z" creationid="hsin" creationdate="20140517T070838Z">
        <seg>배포 환경에서는 라우팅 레이어가 외부에 공개된 호스트 이름으로부터 내부의 포트에 바인딩된 웹 프로세스에 요청을 라우트합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In server-based environments they are commonly written to a file on disk (a "logfile");</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140430T235625Z" creationid="nacyot" creationdate="20140430T232740Z">
        <seg>일반적으로 서버 기반 환경 위에서 로그는 파일 시스템("로그 파일")에 쓰여진다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In staging or production deploys, each process' stream will be captured by the execution environment, collated together with all other streams from the app, and routed to one or more final destinations for viewing and long-term archival.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T104948Z" creationid="nacyot" creationdate="20140518T104948Z">
        <seg>스테이징이나 프로덕션 배포에서는 각각의 프로세스 스트림은 실행환경에 의해 포착되며 어플리케이션으로부터 발생하는 다른 모든 스트림과 함께 정렬되며 표시나 장기 아카이브를 위해 하나나 여러 목적지에 보내진다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In the modern era, software is commonly delivered as a service: called *web apps*, or *software-as-a-service*.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T134414Z" creationid="nacyot" creationdate="20140518T125832Z">
        <seg>지금 시대에서 소프트웨어는 일반적으로 서비스로서 제공되며 *웹 어플리케이션(web app)*이나 *서비스로서의 소프트웨어(software-as-a-service)*라고 불린다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In the modern era, software is commonly delivered as a service: called *web apps*, or *software-as-a-service*.  The twelve-factor app is a methodology for building software-as-a-service apps that:</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140429T225110Z" creationid="nacyot" creationdate="20140429T224933Z">
        <seg>현대에 소프트웨어는 서비스로 제공되며 *웹 어플리케이션(web apps)*이나 *Soft as a Service*라고 이야기되곤 합니다. The Twelve-factor App은 Software as a service을 작성하는 방법론을 담고 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In the simplest case, the code is a stand-alone script, the execution environment is a developer's local laptop with an installed language runtime, and the process is launched via the command line (for example, `python my_script.py`).</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T171606Z" creationid="nacyot" creationdate="20140517T171606Z">
        <seg>가장 간단한 경우를 예로 들자면 코드는 하나의 스크립트이고 실행 환경은 개발자의 로컬 노트북이라고 할 때 프로세스는 명령행을 통해 실행됩니다(for example, `python my_script.py`). </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In, Python there are two separate tools for these steps -- [Pip](http://www.pip-installer.org/en/latest/) is used for declaration and [Virtualenv](http://www.virtualenv.org/en/latest/) for isolation.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T143231Z" creationid="nacyot" creationdate="20140511T153919Z">
        <seg>파이썬에서는 이러한 작업이 두 단계에 걸쳐서 이루어진다. [Pip](http://www.pip-installer.org/en/latest/)는 의존성 선언에 사용되며, [Virtualenv](http://www.virtualenv.org/en/latest/)는 의존성 분리에 사용된다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Instead, each running process writes its event stream, unbuffered, to `stdout`.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T104732Z" creationid="nacyot" creationdate="20140518T104732Z">
        <seg>대신에 각각의 실행중인 프로세스는 자신의 이벤트 스트림을 버퍼없이 `stdout`에 출력한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Instead, rely on the operating system's process manager (such as [Upstart](http://upstart.ubuntu.com/), a distributed process manager on a cloud platform, or a tool like [Foreman](http://blog.daviddollar.org/2011/05/06/introducing-foreman.html) in development) to manage [output streams](/logs), respond to crashed processes, and handle user-initiated restarts and shutdowns.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T174627Z" creationid="nacyot" creationdate="20140517T174627Z">
        <seg>대신에 OS의 프로세스 매니져 (예를 들어 [Upstart](http://upstart.ubuntu.com), 클라우드 플랫폼 프로세스 매니저 또는 개발 환경의 [Foreman](http://blog.daviddollar.org/2011/05/06/introducing-foreman.html) 같은 툴)을 사용해 출력 스트림을 관리하고 프로세스 실패에 대응하고, 사용자에 의한 재기동 및 셧다운을 관리해야한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Introduction
============</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140429T224822Z" creationid="nacyot" creationdate="20140429T224822Z">
        <seg>시작하며
============</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It is a triangulation on ideal practices app development, paying particular attention to the dynamics of the organic growth of an app over time, the dynamics of collaboration between developers working on the app's codebase, and [avoiding the cost of software erosion](http://blog.heroku.com/archives/2011/6/28/the_new_heroku_4_erosion_resistance_explicit_contracts/).</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T140658Z" creationid="nacyot" creationdate="20140518T125003Z">
        <seg>이는 어플리케이션 개발의 이상적인 프렉티스에 대한 삼각측량법이다. 여기서는 특히 시간에 따른 어플리케이션의 유기적 성장에 대한 역학, 어플리케이션의 코드베이스를 둘러썬 프로그래머 간의 협업의 역학, 그리고 [소프트웨어 부패에 대한 비용 회피]에 주목하고 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Its `rollback` command makes it easy to quickly roll back to a previous release.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T091231Z" creationid="nacyot" creationdate="20140518T091231Z">
        <seg>`rollback` 명령어를 사용하면 쉽고 빠르게 이전 릴리스로 되돌릴 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Java processes take the opposite approach, with the JVM providing one massive uberprocess that reserves a large block of system resources (CPU and memory) on startup, with concurrency managed internally via threads.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T173418Z" creationid="nacyot" creationdate="20140517T173418Z">
        <seg>자바 프로그램은 반대 방법을 사용한다. JVM은 하나의 거대한 부모 프로세스를 제공하며 실행할 때 CPU나 메모리 같은 커다란 블록을 확보하며, 쓰레드를 사용해 내부적으로 병행성을 관리한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Libraries installed through a packaging system can be installed system-wide (known as "site packages") or scoped into the directory containing the app (known as "vendoring" or "bundling").</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T142536Z" creationid="nacyot" creationdate="20140511T153218Z">
        <seg>패키지 관리 시스템을 통한 라이브러리 설치는 "site packages"라고 불리는 시스템 전체에 적용되는 설치와 "vendoring"이나 "bundling"라고 불리는 어플리케이션이 포함된 디렉토리에만 적용되는 설치, 두 가지로 나뉜다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Lightweight local services are less compelling than they once were.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T014703Z" creationid="nacyot" creationdate="20140518T014703Z">
        <seg>로컬에서 사용하는 경량 서비스들은 한때 그랬던 만큼 매력적이지 않다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Likewise, a Python program using Virtualenv should use the vendored `bin/python` for running both the Tornado webserver and any `manage.py` admin processes.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T160716Z" creationid="nacyot" creationdate="20140517T160716Z">
        <seg>마찬가지로 Virtualenv를 사용하는 파이썬  프로그램의 경우 가상환경 내의`bin/python`을 Tornado 웹서버를 비롯해 모든 `manage.py`를 사용하는 명령어에 마찬가지로 사용해야한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Likewise, a local SMTP server could be swapped with a third-party SMTP service (such as Postmark) without code changes.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T163021Z" creationid="nacyot" creationdate="20140517T163011Z">
        <seg>마찬가지로 로컬에서 관리되는 SMTP 서버도 코드 변경없이 Postmark와 같은 써드파티 SMTP  서비스와 교체될 수 있어야합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Lock-based systems such as [Delayed Job](https://github.com/collectiveidea/delayed_job#readme) need to be sure to release their lock on the job record.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T023346Z" creationid="nacyot" creationdate="20140518T023346Z">
        <seg>[Delayed Job](https://github.com/collectiveidea/delayed_job#readme)과 같은 락을 베이스로 한 시스템에서는 잡 레코드에서 해당하는 락을 확실히 풀어줄 필요가 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Logs are the [stream](http://adam.heroku.com/past/2011/4/1/logs_are_streams_not_files/) of aggregated, time-ordered events collected from the output streams of all running processes and backing services.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140430T235633Z" creationid="nacyot" creationdate="20140430T235612Z">
        <seg>로그는 모든 실행중인 프로세스와 백엔드 서비스에서 시간순으로 정렬되고 쌓여있는 이벤트를 수집하는 스트림이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Logs have no fixed beginning or end, but flow continously as long as the app is operating.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T104548Z" creationid="nacyot" creationdate="20140518T104548Z">
        <seg>로그는 고정된 시작과 끝이 없으면 어플리케이션이 실행되는 한 계속된다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Logs in their raw form are typically a text format with one event per line (though backtraces from exceptions may span multiple lines).</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T104503Z" creationid="nacyot" creationdate="20140512T225912Z">
        <seg>일반적으로 어플리케이션이 직접 생성한 로그는 한 줄에 하나의 이벤트를 기록하고 있는 텍스트 포맷이다.(예외적으로 여러에 걸치는 경우도 있지만)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Many languages offer libraries which simplify access to the backing service, including *adapters* to different types of services.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T010153Z" creationid="nacyot" creationdate="20140518T010153Z">
        <seg>많은 언어는 서로 다른 종류의 서비스에 대한 어답타를 포함해 특정 백엔드 서비스에 대해 간단히 사용할 수 있게 라이브러리를 제공한다. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Meta
----</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T170903Z" creationid="nacyot" creationdate="20140517T170903Z">
        <seg>Meta
----</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Modern backing services such as Memcached, PostgreSQL, and RabbitMQ are not difficult to install and run thanks to modern packaging systems, such as [Homebrew](http://mxcl.github.com/homebrew/) and [apt-get](https://help.ubuntu.com/community/AptGet/Howto).</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T015156Z" creationid="nacyot" creationdate="20140518T015156Z">
        <seg>Memcached, PostgreSQL, RabbitMQ와 같은 모던한 백엔드 서비스는 [Homebrew](http://mxcl.github.com/homebrew/)이나 [apt-get](https://help.ubuntu.com/community/AptGet/Howto) 같은 모던한 패키지 관리 시스템 덕분에 설치하는 게 어렵지 않다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Most languages provide a REPL by running the interpreter without any arguments (e.g. `python` or `erl`) or in some cases have a separate command (e.g. `irb` for Ruby, `rails console` for Rails).</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T160202Z" creationid="nacyot" creationdate="20140517T160202Z">
        <seg>많은 언어에서는 별다른 인자없이 인터프리터를 실행하면 REPL을 실행할 수 있다. 혹은 루비의 `irb`나 `rails console`과 같이 별도의 명령어를 제공하기도 한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Most programming languages offer a packaging system for distributing support libraries, such as [CPAN](http://www.cpan.org/) for Perl or [Rubygems](http://rubygems.org/) for Ruby.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T142349Z" creationid="nacyot" creationdate="20140511T152411Z">
        <seg>많은 프로그래밍 언어에서 Perl의 [CPAN](http://www.cpan.org/)이나 루비의 [루비젬](http://rubygems.org/)과 같은 의존 라이브러리 관리를 위한 패키지 관리 시스템을 제공한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Most significantly, the stream can be sent to a log indexing and analysis system such as [Splunk](http://www.splunk.com/), or a general-purpose data warehousing system such as [Hadoop/Hive](http://hive.apache.org/).</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T105221Z" creationid="nacyot" creationdate="20140518T105221Z">
        <seg>가장 중요한 용도로 스트림은 로그 인덱스와 분석에 사용되는 [Splunk](http://www.splunk.com/)나 범용 데이터 웨어하우스 시스템은 [Hadoop/Hive](http://hive.apache.org/)에 보내질 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Nearly any kind of server software can be run via a process binding to a port and awaiting incoming requests.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T121215Z" creationid="nacyot" creationdate="20140518T121215Z">
        <seg>거의 모든 서버 소프트웨어는 포트를 바인딩하는 프로세스를 통해서 동작하며 요청을 기다린다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>No matter what the toolchain, dependency declaration and isolation must always be used together -- only one or the other is not sufficient to satisfy twelve-factor.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T143323Z" creationid="nacyot" creationdate="20140511T154111Z">
        <seg>어떤 툴을 사용하건 간에 의존관계 선언과 분리는 항상 함께 사용되어야 한다. 어느 한 쪽만을 사용하는 것은 Twelve Factor를 만족하지 않는다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Note also that the port-binding approach means that one app can become the [backing service](/backing-services) for another app, by providing the URL to the backing app as a resource handle in the [config](/config) for the consuming app.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T121444Z" creationid="nacyot" creationdate="20140518T121416Z">
        <seg>여기서 주목해야할 점은 포트 바인딩에 의해 어떤 어플리케이션이 다른 어플리케이션에 대한 [백엔드 서비스](/backing-services)가 된다는 점이다. 백엔드 어플리케이션에 대한 URL이 제공되며 이용하는 어플리케이션은 [설정](/config)에 리소스 핸들을 저장하면 된다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Note that this definition of "config" does **not** include internal application config, such as `config/routes.rb` in Rails, or how [code modules are connected](http://static.springsource.org/spring/docs/2.5.x/reference/beans.html) in [Spring](http://www.springsource.org/).</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T164913Z" creationid="nacyot" creationdate="20140517T164913Z">
        <seg>또한 여기서 "설정"이라는 단어의 정의는 어플리케이션 내부의 설정을 포함하지 않는다는 점에 주의할 필요가 있다. 예를 들어 레일스의 `config/routes.rb`나 스프링의 [코드 모듈이 어떻게 연결되어있는지](http://static.springsource.org/spring/docs/2.5.x/reference/beans.html)는 어플리케이션 내부 설정이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>On the other end of the spectrum, a production deploy of a sophisticated app may use many [process types, instantiated into zero or more running processes](/concurrency).</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T121626Z" creationid="nacyot" creationdate="20140518T121626Z">
        <seg>다른 방향의 끝에는 0개나 여러개의 실행중인 프로세스들로 초기화되는 다양한 타입의 프로세스를 사용하는 세련된 어플리케이션이 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>One benefit of explicit dependency declaration is that it simplifies setup for developers new to the app.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T143409Z" creationid="nacyot" creationdate="20140511T154201Z">
        <seg>의존성을 명시적으로 선언함으로써 얻는 다른 효과는 새로운 프로그래머가 어플리케이션 개발에 참여할 때 개발 환경을 쉽게 구성할 수 있다는 점이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>One-off admin processes should be run in an identical environment as the regular [long-running processes](/processes) of the app.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T160321Z" creationid="nacyot" creationdate="20140517T160321Z">
        <seg>한 번만 실행되는 프로세스들은 일반적으로 [장기간 실행되는 프로세스들](/processes)과 같은 환경에서 실행되어야한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Open-source log routers (such as [Logplex](https://github.com/heroku/logplex) and [Fluent](https://github.com/fluent/fluentd)) are available for this purpose.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T105054Z" creationid="nacyot" creationdate="20140518T105054Z">
        <seg>[Logplex](https://github.com/heroku/logplex)나 [Fluent](https://github.com/fluent/fluentd)와 같은 오픈소스 로그 라우터가 이러한 목적으로 사용된다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Ops engineers who deploy or manage such applications.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T140813Z" creationid="nacyot" creationdate="20140517T170953Z">
        <seg>이러한 어플리케이션을 배포하고 관리하는 Ops 엔지니어(서버 관리자)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Our motivation is to raise awareness of some systemic problems we've seen in modern application development, to provide a shared vocabulary for discussing those problems, and to offer a set of broad conceptual solutions to those problems with accompanying terminology.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T140528Z" creationid="nacyot" creationdate="20140518T125123Z">
        <seg>이 책을 집필한 동기는, 우리가 모던한 어플리케이션 개발에서 부딪혀온 특정한 종류의 시스템 문제에 대한 관심을 높이고자함이다. 나아가 이러한 문제를 논의 하기 위한 어휘를 제공하고, 이 문제에 대한 넓고 개념적인 해결책을 전문용어와 함께 제공하는 것이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Processes **shut down gracefully when they receive a [SIGTERM](http://en.wikipedia.org/wiki/SIGTERM)** signal from the process manager.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T022424Z" creationid="nacyot" creationdate="20140518T022424Z">
        <seg>프로세스들은 프로세스 매니저로부터 **[SIGTERM](http://en.wikipedia.org/wiki/SIGTERM) 받을 때 정상적으로 종료된다**.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Processes should also be **robust against sudden death**, in the case of a failure in the underlying hardware.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T023543Z" creationid="nacyot" creationdate="20140518T023543Z">
        <seg>프로세스는 저수준의 하드웨어 이상한에 대해서도 **갑작스러운 종료로 부터 견고해야한다.**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Processes should strive to **minimize startup time**.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T021627Z" creationid="nacyot" creationdate="20140518T021627Z">
        <seg>프로세스는 **시간 시간 최소화**를 위해 최대한 노력해야한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Production deploy
-----------------</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T170903Z" creationid="nacyot" creationdate="20140517T170903Z">
        <seg>Production deploy
-----------------</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Released under the MIT License: http://www.opensource.org/licenses/mit-license.php</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T170913Z" creationid="nacyot" creationdate="20140517T170913Z">
        <seg>Released under the MIT License: http://www.opensource.org/licenses/mit-license.php</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Releases are an append-only ledger and a release cannot be mutated once it is created.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T091435Z" creationid="nacyot" creationdate="20140518T091435Z">
        <seg>릴리스는 기업만 가능한 원장이자 한번 만들어진 릴리스는 변경할 수 없다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Resources can be attached and detached to deploys at will.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T163354Z" creationid="nacyot" creationdate="20140517T163354Z">
        <seg>리소스는 자유롭게 어태치되거나 디태치될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Runtime execution, by contrast, can happen automatically in cases such as a server reboot, or a crashed process being restarted by the process manager.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T091557Z" creationid="nacyot" creationdate="20140518T091557Z">
        <seg>반면에 실행 단계는 서버의 재시작이나 종료된 프로세스가 프로세스 매니저에 의해 재시작 되는 등 자동적으로 개시된다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Separately, developers will often wish to do one-off administrative or maintenance tasks for the app, such as:</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T155925Z" creationid="nacyot" creationdate="20140517T155925Z">
        <seg>이와는 별개로 개발자는 관리나 유지보수 목적으로 한번만 실행되는 태스크를 실행하고 싶을 수 있다. 예를 들면 아래와 같은 것들이 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Session state data is a good candidate for a datastore that offers time-expiration, such as [Memcached](http://memcached.org/) or [Redis](http://redis.io/).</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T124710Z" creationid="nacyot" creationdate="20140518T124710Z">
        <seg>세션 상태 데이터는 만료 시간(혹은 유효시간)과 함께 [Memcached](http://memcached.org/)나 [Redis](http://redis.io/)에 저장되어야한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Short startup time provides more agility for the [release](/build-release-run) process and scaling up;</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T022215Z" creationid="nacyot" creationdate="20140518T022215Z">
        <seg>짧은 시작 시간은 [릴리스](/build-release-run)와 스케일 업에 있어서 애자일하게 만들어준다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Some examples are in the table below.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T010209Z" creationid="nacyot" creationdate="20140518T010209Z">
        <seg>아래 표는 그 예를 보여준다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Some web systems rely on ["sticky sessions"](http://en.wikipedia.org/wiki/Load_balancing_%28computing%29#Persistence) -- that is, caching user session data in memory of the app's process and expecting future requests from the same visitor to be routed to the same process.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T124655Z" creationid="nacyot" creationdate="20140518T124649Z">
        <seg>몇몇 웹 시스템은 ["Sticky 세션](http://en.wikipedia.org/wiki/Load_balancing_%28computing%29#Persistence)에 의존하기도 한다. 이는 사용자 세션 데이터를 어플리케이션 프로세스의 메모리에 캐시해 같은 방문자의 이후 요청이 같은 프로세스에 보내질 것을 기대하는 것을 말한다.   </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Sometimes apps batch config into named groups (often called "environments") named after specific deploys, such as the `development`, `test`, and `production` environments in Rails.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T170743Z" creationid="nacyot" creationdate="20140517T170743Z">
        <seg>어플리케이션 설정은 이름 공간으로 구분되는 그룹(주로 "환경(environment)"라고 이야기된다)으로 구분된다. 예를 들어 레일스에서는 `development`와 `test`, `production`를 일반적으로 사용ㅎㄴ다. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Source for the content app running at: http://www.12factor.net/</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T170902Z" creationid="nacyot" creationdate="20140517T170902Z">
        <seg>Source for the content app running at: http://www.12factor.net/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Sticky sessions are a violation of twelve-factor and should never be used or relied upon.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T124651Z" creationid="nacyot" creationdate="20140518T124651Z">
        <seg>스티키 세션은 Twelve-Factor에 위배되며 결코 이에 의존해서는 안된다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Summarizing the above into a table:</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T005829Z" creationid="nacyot" creationdate="20140518T005829Z">
        <seg>표로 요약하면 다음과 같다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The Twelve Factors
==================</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140429T154426Z" creationid="nacyot" creationdate="20140429T154426Z">
        <seg>The Twelve Factors
==================</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The Twelve-Factor App
=====================</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T170902Z" creationid="nacyot" creationdate="20140517T170902Z">
        <seg>The Twelve-Factor App
=====================</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The [process formation](/concurrency) is the array of processes that are used to do the app's regular business (such as handling web requests) as it runs.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T155842Z" creationid="nacyot" creationdate="20140517T155842Z">
        <seg>[프로세스 포메이션](/concurrency)이란 어플리케이션을 실행할 때 통상적인 역할(웹 리퀘스트 처리 등)을 다루기 위한 프로세스들을 이야기한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The [share-nothing, horizontally partitionable nature of twelve-factor app processes](/processes) means that adding more concurrency is a simple and reliable operation.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T174224Z" creationid="nacyot" creationdate="20140517T174224Z">
        <seg>아무것도 공유하지 않는 수평 분할 가능한 Twelve-Fatro App의 프로세스 설질은 병행성을 높이는 조작이 단순할 분만 아니라 확실하다는 의미를 가진다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The app is executed in the execution environment as one or more *processes*.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T171504Z" creationid="nacyot" creationdate="20140517T171504Z">
        <seg>어플리케이션은 실행 환경 안에서 하나나 여러개의 *프로세스들*로 실행됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The array of process types and number of processes of each type is known as the *process formation*.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T174307Z" creationid="nacyot" creationdate="20140517T174307Z">
        <seg>프로세스 타입과 각 타입의 프로세수 수 배열은 *프로세스 포메이션*이라고 불린다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The build stage can be more complex, since errors are always in the foreground for a developer who is driving the deploy.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T104335Z" creationid="nacyot" creationdate="20140518T104335Z">
        <seg>빌드 단계는 복잡해도 무방하다. 왜냐면 빌드 스테이지의 단계의 에러는 배포를 하는 개발자 앞에서 발생하기 때문이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The codebase is the same across all deploys, although different versions may be active in each deploy.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T141926Z" creationid="nacyot" creationdate="20140517T172733Z">
        <seg>다수의 배포들은 서로 다른 버전일 수도 있지만, 모든 배포는 하나의 코드베이스를 가진다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The contract with the execution environment is binding to a port to serve requests.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T111525Z" creationid="nacyot" creationdate="20140518T111525Z">
        <seg>요청을 처리하기 위한 실행환경과의 규약은 포트 바인등을 하는 것이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The contributors to this document have been directly involved in the development and deployment of hundreds of apps, and indirectly witnessed the development, operation, and scaling of hundreds of thousands of apps via our work on the [Heroku](http://www.heroku.com/) platform.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T135529Z" creationid="nacyot" creationdate="20140429T232056Z">
        <seg>이 문서의 작성자는 수백개 어플리케이션의 개발과 배포에 직접적으로 관여했으며, [히로쿠(Heroku)](http://www.heroku.com/) 플랫폼에서 일하면서 수천개 어플리케이션의 개발(development), 운용(operation), 확장(scaling)에 간접적으로 참여했다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The cost of installing and using these systems is low compared to the benefit of dev/prod parity and continuous deployment.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T020358Z" creationid="nacyot" creationdate="20140518T020358Z">
        <seg>개발 프로덕션 환경 일치와 계속적 배포의 이점을 생각하면 이러한 백엔드 서비스를 설치하는 비용은 매우 작다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The cost of this friction and the subsequent dampening of continuous deployment is extremely high when considered in aggregate over the lifetime of an application.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T014636Z" creationid="nacyot" creationdate="20140518T014636Z">
        <seg>이러한 방해 요소로 인해 배포가 되지 않는 점은 어플리케이션 라이프 사이클에 있어서 매우 비싼 코스트가 된다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The current production database could be detached, and the new database attached -- all without any code changes.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T163506Z" creationid="nacyot" creationdate="20140517T163506Z">
        <seg>그리고 기존의 프로덕션 데이터베이션를 디테치하고 새로운 데이터베이스를 어태치합니다. 이 과정에 어떠한 코드 변화도 없습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The event stream for an app can be routed to a file, or watched via realtime tail in a terminal.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T105128Z" creationid="nacyot" creationdate="20140518T105125Z">
        <seg>어플리케이션의 이벤트 스트림은 파일로 보내지거나 터미널에서 tail 명령어를 사용해 실시간으로 볼 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The format is inspired by Martin Fowler's books *[Patterns of Enterprise Application Architecture](http://books.google.com/books/about/Patterns_of_enterprise_application_archi.html?id=FyWZt5DdvFkC)* and *[Refactoring](http://books.google.com/books/about/Refactoring.html?id=1MsETFPD3I0C)*.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T140459Z" creationid="nacyot" creationdate="20140518T125155Z">
        <seg>이 책의 형식은 Martin Fowler의 서적 *[Patterns of Enterprise Application Architecture](http://books.google.com/books/about/Patterns_of_enterprise_application_archi.html?id=FyWZt5DdvFkC)*과 *[Refactoring](http://books.google.com/books/about/Refactoring.html?id=1MsETFPD3I0C)*의 영향을 받았다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The full and explicit dependency specification is applied uniformly to both production and development.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T143127Z" creationid="nacyot" creationdate="20140511T153612Z">
        <seg>의존성 선언 명시적이어야하며 모든 의존 라이브러리를 포함해야한다. 이러한 의존성 선언은 개발 환경과 프로덕션 환경 모두에 적용된다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The memory space or filesystem of the process can be used as a brief, single-transaction cache.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T121915Z" creationid="nacyot" creationdate="20140518T121915Z">
        <seg>프로세스의 메모리 공간이나 파일 시스템은 짧은 단일 트랜젝션을 위한 캐시로 사용해도 무방하다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The new developer can check out the app's codebase onto their development machine, requiring only the language runtime and dependency manager installed as prerequisites.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T143600Z" creationid="nacyot" creationdate="20140511T154313Z">
        <seg>새로운 프로그래머가 어플리케이션의 코드베이스를 개발 머신에 가져오는 데 필요한 것은 개발에 사용되는 프로그래밍 언어 런타임과 의존성 관리 도구뿐이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The process model truly shines when it comes time to scale out.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T174138Z" creationid="nacyot" creationdate="20140517T174138Z">
        <seg>이러한 프로세스 모델의 진가는 스케일 아웃이 필요한 경우이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The resulting *release* contains both the build and the config and is ready for immediate execution in the execution environment.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T090808Z" creationid="nacyot" creationdate="20140518T090808Z">
        <seg>*릴리스*의 결과는 빌드와 설정이 포함되며 실행 환경에서 바로 실행될 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The same [dependency isolation](/dependencies) techniques should be used on all process types.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T160558Z" creationid="nacyot" creationdate="20140517T160529Z">
        <seg>모든 프로세스 타입들에 대해서 같은 [의존성 분리](/dependencies) 기법들이 사용되어야한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The solution here is to factor shared code into libraries which can be included through the [dependency manager](/dependencies).</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T141609Z" creationid="nacyot" creationdate="20140517T172430Z">
        <seg>이러한 문제를 해결하려면, 먼저 공통된 부분을 라이브러리로 분리하고 이 라이브러리를 [의존성 관리](/dependencies)를 통해서 사용하면 된다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The twelve-factor app is a methodology for building software-as-a-service apps that:</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T134719Z" creationid="nacyot" creationdate="20140518T125853Z">
        <seg>Twelve-Factor App은 아래와 같은 "서비스로서의 소프트웨어"를 만드는 방법론이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The twelve-factor app never assumes that anything cached in memory or on disk will be available on a future request or job -- with many processes of each type running, chances are high that a future request will be served by a different process.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T122108Z" creationid="nacyot" creationdate="20140518T122108Z">
        <seg>Twelve-Factor App에서는 메모리나 디스크에 캐시된 정보가 이후에 리퀘스트나 작업을 처리하는 데서 재사용된다고 결코 가정하지 않는다. 각각의 프로세스 타입의 프로세스가 많이 실행되는 경우 미래의 요청이나 작업은 다른 프로세스에서 실행될 가능성이 높다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The twelve-factor app treats these databases as *attached resources*, which indicates their loose coupling to the deploy they are attached to.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T163327Z" creationid="nacyot" creationdate="20140517T163327Z">
        <seg>Twelve-Factor App은 이러한 데이터베이스들을 *붙어있는 리소스*로 다룹니다. 이는 어태치된 리소스와 어태치되는 대상의 배포가 얕은 커플링을 가진다는 의미입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The twelve-factor methodology can be applied to apps written in any programming language, and which use any combination of backing services (database, queue, memory cache, etc).</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T135425Z" creationid="nacyot" creationdate="20140429T231829Z">
        <seg>Twelve-Factor App 방법론은 어떤 프로그래밍 언어로 만들어진 어플리케이션에도 적용할 수 있다. 또한 어떤 백엔드 서비스(데이터베이스, 큐, 메모리 캐시 등등)에도 적용할 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The web app **exports HTTP as a service by binding to a port**, and listening to requests coming in on that port.</seg>
      </tuv>
      <tuv lang="KO" changeid="hsin" changedate="20140517T063720Z" creationid="hsin" creationdate="20140517T063720Z">
        <seg>웹 어플리케이션은 ** 포트 바인딩을 통해서 HTTP를 서비스로 공개하며 이 포트에 오는 요청을 기다린다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>There is always a one-to-one correlation between the codebase and the app:</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T172158Z" creationid="nacyot" creationdate="20140517T172158Z">
        <seg>코드베이스와 어플리케이션 간에는 항상 1:1의 관계가 성립한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>There is only one codebase per app, but there will be many deploys of the app.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T141648Z" creationid="nacyot" creationdate="20140517T172458Z">
        <seg>코드베이스는 각 어플리케이션마다 단 하나만 존재하지만, 어플리케이션은 여러 번 배포될 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Therefore, the run stage should be kept to as few moving parts as possible, since problems that prevent an app from running can cause it to break in the middle of the night when no developers are on hand.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T104228Z" creationid="nacyot" creationdate="20140518T104228Z">
        <seg>따라서 실행 단계는 가능한한 변경 가능하는 부분을 줄여한다. 이는 어플리케이션 실행을 방해하는 문제가 발생했을 때 개발자가 대기하지 않는 시간에 발생하면 어플리케이션이 작동하지 않기 때문이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>These archival destinations are not visible to or configurable by the app, and instead are completely managed by the execution environment.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T105024Z" creationid="nacyot" creationdate="20140518T105024Z">
        <seg>이들을 저장하기 위한 목적지는 어플리케이션에서는 볼 수도 없고 설정할 수도 없으며  대신에 실행 환경에 의해 완전히 관리된다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>These gaps manifest in three areas:</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T005335Z" creationid="nacyot" creationdate="20140518T005335Z">
        <seg>이러한 차이는 크게 3가지로 나타난다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>These systems allow for great power and flexibility for introspecting an app's behavior over time, including:</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T105254Z" creationid="nacyot" creationdate="20140518T105254Z">
        <seg>이러한 시스템은 장기적인 관점에서 어플리케이션의 작동을 확인하는데 강력한 능력과 유연성을 제공하며 다음과 같은 일을 할 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>These types of errors create friction that disincentivizes continuous deployment.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T014552Z" creationid="nacyot" creationdate="20140518T014552Z">
        <seg>이런 종류의 에러는 계속적 배포를 방해하는 요소가 된다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>They are never grouped together as "environments," but instead are independently managed for each deploy.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T125636Z" creationid="nacyot" creationdate="20140518T125636Z">
        <seg>환경변수가 "환경"으로 그룹화되어지지는 않지만 대신에 배포 단위로 독립적으로 관리된다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>They run against a [release](/build-release-run), using the same [code](/code) and [config](/config) as any process run against that release.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T160433Z" creationid="nacyot" creationdate="20140517T160433Z">
        <seg>이러한 프로세스들은 특정 [릴리스](/build-release-run)에 대해서 실행되어야 하면 이 릴리스에 대해서 실행되는 모든 프로세스와 같은 [코드](/code)와 [설정](/config)을 사용해야한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>They will be able to set up everything needed to run the app's code with a deterministic *build command*.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T143628Z" creationid="nacyot" creationdate="20140511T154629Z">
        <seg>여기에 *빌드 명령어* 하나면 어플리케이션 개발에 필요한 모든 설정을 할 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This document synthesizes all of our experience and observations on a wide variety of software-as-a-service apps in the wild.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T140609Z" creationid="nacyot" creationdate="20140430T232055Z">
        <seg>이 문서는 실무에서 다양하게 사용되는 "서비스로서의 소프트웨어" 어플리케이션들에 대한 우리의 모든 경험과 관찰을 집약한 책입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This does not exclude individual processes from handling their own internal multiplexing, via threads inside the runtime VM, or the async/evented model found in tools such as [EventMachine](http://rubyeventmachine.com/), [Twisted](http://twistedmatrix.com/trac/), or [Node.js](http://nodejs.org/).</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T174015Z" creationid="nacyot" creationdate="20140517T174015Z">
        <seg>이러한 모델은 런타임 VM 내의 쓰레드나 [EventMachine](http://rubyeventmachine.com/), [Twisted](http://twistedmatrix.com/trac/), [Node.js](http://nodejs.org/) 등 비동기 이번트 모델에 의해 각각의 프로세스가 프로세스 내부에서 다중화되는 것을 금지하지 않는다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This happens entirely in *user space*, that is, within the app's code.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T111502Z" creationid="nacyot" creationdate="20140518T111502Z">
        <seg>이는 이른바 *사용자 공간*, 즉 어플리케이션 코드 내에서 완결된다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This includes:</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T144213Z" creationid="nacyot" creationdate="20140517T164317Z">
        <seg>설정에는 아래와 같은 것들을 포함된다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is a huge improvement over using constants which are checked into the code repo, but still has weaknesses: it's easy to mistakenly check in a config file to the repo;</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T170209Z" creationid="nacyot" creationdate="20140517T170209Z">
        <seg>이러한 방법은 버전 관리 시스템에 포함된 코드에 상수로 설정을 저장하는 것보다는 매우 큰 발전이지만 여전히 단점이 남아있다. 먼저 실수로 파일을 버전 관리에 포함시키기 쉽다는 점이 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is a model that scales up smoothly as the app naturally expands into more deploys over its lifetime.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T125704Z" creationid="nacyot" creationdate="20140518T125704Z">
        <seg>이는 어플리케이션 라이프 사이클에 있어서 어플리케이션이 많은 배포에 자연스럽게 확대해감에 따라 자연스럽게 스케일 업이 가능한 모델이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is a violation of twelve-factor, which requires **strict separation of config from code**.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T164542Z" creationid="nacyot" creationdate="20140517T164542Z">
        <seg>이는 Twelve-Factor에 위배되는 것으로 설정은 엄격하게 코드와 분리되어야한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is typically a production site, and one or more staging sites.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T141727Z" creationid="nacyot" creationdate="20140517T172556Z">
        <seg>일반적으로 하나의 어플리케이션은 하나의 프로덕션 사이트와, 다수의 스테이징 사이트로 배포된다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is typically implemented by using [dependency declaration](/dependencies) to add a webserver library to the app, such as [Tornado](http://www.tornadoweb.org/) for Python, [Thin](http://code.macournoyer.com/thin/) for Ruby, or [Jetty](http://jetty.codehaus.org/jetty/) for Java and other JVM-based languages.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T111438Z" creationid="nacyot" creationdate="20140518T111438Z">
        <seg>이는 일반적으로 [의존성 선언](/dependencies)을 통해서 웹 서버 라이브리러를 어플리케이션에 추가하는 방법으로 구현된다. 웹 서버 라이브러리의 예로는 Python의 [Tornado](http://www.tornadoweb.org/), 루비의 [Thin](http://code.macournoyer.com/thin/), 자바나 JVM 기반 언어들의 [Jetty](http://jetty.codehaus.org/jetty/) 등이 있다. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This method does not scale cleanly: as more deploys of the app are created, new environment names are necessary, such as `staging` or `qa`.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T125319Z" creationid="nacyot" creationdate="20140518T125319Z">
        <seg>이러한 방법은 스케일에 적합하지 않다. 어플리케이션의 배포가 늘어감에 따라 `staging`나 `qa`와 같은 환경의 이름이 필요해진다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This type of config does not vary between deploys, and so is best done in the code.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T165849Z" creationid="nacyot" creationdate="20140517T165849Z">
        <seg>이러한 종류의 설정은 배포 환견 간에 큰 차이가 없으며, 따라서 코드에서 저장하는 게 최선이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Twelve-factor app processes [should never daemonize](http://dustin.github.com/2010/02/28/running-processes.html) or write PID files.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T174414Z" creationid="nacyot" creationdate="20140517T174414Z">
        <seg>Twelve-Factor App 프로세스는 [결코 데몬화](http://dustin.github.com/2010/02/28/running-processes.html)되어서는 안되며 PID 파일을 작성할 필요도 없다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Twelve-factor apps also do not rely on the implicit existence of any system tools.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T143840Z" creationid="nacyot" creationdate="20140511T154815Z">
        <seg>또한 Twelve-Factor App은 시스템 전체에 적용되는 특정한 프로그램이 설치되어있다고 전제하지 않는다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Twelve-factor strongly favors languages which provide a REPL shell out of the box, and which make it easy to run one-off scripts.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T160839Z" creationid="nacyot" creationdate="20140517T160839Z">
        <seg>Twelve-factor는 특별한 설정없이도 REPL을 사용할 수 있는 언어를 선호한다. 이는 1번만 사용하는 스크립트를 실행하기 쉽기 때문이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Using a version of the code at a commit specified by the deployment process, the build stage fetches and vendors [dependencies](/dependencies) and compiles binaries and assets.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T090655Z" creationid="nacyot" creationdate="20140518T090655Z">
        <seg>배포 과정에 의해 지정된 특정 커밋의 코드를 사용해 빌드 스테이지는 [의존성](/dependencies)을 설치하고 바이너리와 에셋 파일을 컴파일한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Using this model, the developer can architect their app to handle diverse workloads by assigning each type of work to a *process type*.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T173718Z" creationid="nacyot" creationdate="20140517T173718Z">
        <seg>이러한 모델을 사용해 각각의 워크로드의 종류를 프로세스 타입에 따라 나눠주며 개발자는 어플리케이션이 다양한 워크로드를 처리할 수 잇도록 설계할 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Web apps are sometimes executed inside a webserver container.</seg>
      </tuv>
      <tuv lang="KO" changeid="hsin" changedate="20140517T063126Z" creationid="hsin" creationdate="20140517T062951Z">
        <seg>웹 어플리케이션은 웹 서버 컨테이너 안에서 실행되기도 한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Web apps have taken a variety of process-execution forms.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T173032Z" creationid="nacyot" creationdate="20140517T173032Z">
        <seg>웹 어플리케이션 역시 다양한 프로세스 실행 형태로 파악될 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>While these tools may exist on many or even most systems, there is no guarantee that they will exist on all systems where the app may run in the future, or whether the version found on a future system will be compatible with the app.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T144039Z" creationid="nacyot" creationdate="20140511T155114Z">
        <seg>이러한 프로그램들은 대개 시스템 기반으로 설치되는데, 미래에 이 어플리케이션을 돌릴 모든 시스템에 이 프로그램이 설치되어있다고 단언할 수 없으며, 설사 설치되어있다고 해도 어플리케이션과 호환되는 버전이라는 보장은 어디에도 없다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>While this is a much less common occurrence than a graceful shutdown with `SIGTERM`, it can still happen.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T023613Z" creationid="nacyot" creationdate="20140518T023613Z">
        <seg>이러한 일은 `SIGTERM`의 신호에 의한 정상적인 종료에 비해서는 드물게 일어나지만 분명 일어날 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Who should read this document?</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T140839Z" creationid="nacyot" creationdate="20140517T170933Z">
        <seg>어떤 사람이 이 문서를 읽어야 하나요?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>[Backing services](/backing-services), such as the app's database, queueing system, or cache, is one area where dev/prod parity is important.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T010052Z" creationid="nacyot" creationdate="20140518T010052Z">
        <seg>데이터베이스나 큐, 캐시와 같은 [백엔드 서비스](/backing-services) 개발 / 프로덕션 환경의 동일화가 중요시 되는 지점중 하나이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>[Crash-only design](http://lwn.net/Articles/191059/) takes this concept to its [logical conclusion](http://docs.couchdb.org/en/latest/intro/overview.html).</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T090358Z" creationid="nacyot" creationdate="20140518T090358Z">
        <seg>[Crash-only](http://lwn.net/Articles/191059/) 설계는 이 컨셉을 이론적 귀결로 이끌어간다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>and it aids robustness, because the process manager can more easily move processes to new physical machines when warranted.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T022331Z" creationid="nacyot" creationdate="20140518T022331Z">
        <seg>또한 프로세스 매니저가 필요에 따라 새로운 물리 머신에 어플리케이션일 이동하므로 더 견고해진다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>and unlike custom config files, or other config mechanisms such as Java System Properties, they are a language- and OS-agnostic standard.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T170607Z" creationid="nacyot" creationdate="20140517T170607Z">
        <seg>또한 독자적인 형식의 설정 파일이나 자바 시스템 프로퍼티와 같은 설정 형식과 달리 환경변수는 언어나 OS에 의존하지 않는 표준이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>bundle install
    foreman start
    open http://localhost:5000</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T170902Z" creationid="nacyot" creationdate="20140517T170902Z">
        <seg>bundle install
    foreman start
    open http://localhost:5000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>but this is only an output format.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140430T235628Z" creationid="nacyot" creationdate="20140430T232754Z">
        <seg>하지만 이는 한 가지 출력 방법일 뿐이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>heroku create -s cedar
    git push heroku master
    heroku open</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T170903Z" creationid="nacyot" creationdate="20140517T170903Z">
        <seg>heroku create -s cedar
    git push heroku master
    heroku open</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>on [Beanstalkd](http://kr.github.com/beanstalkd/), the job is returned to the queue automatically whenever a worker disconnects.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T023257Z" creationid="nacyot" creationdate="20140518T023257Z">
        <seg>[Beanstalkd](http://kr.github.com/beanstalkd/)에서는 워커가 접속이 종료 되었을 때 잡이 자동적으로 큐로 되돌아간다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>or local process memory for caching in development and Memcached in production.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T010539Z" creationid="nacyot" creationdate="20140518T010539Z">
        <seg>개발 중에는 메모리 캐시를 사용하지만 프로덕션에서는 Memcached를 사용하기도 한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>staging has some commits not yet deployed to production.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140518T142053Z" creationid="nacyot" creationdate="20140517T172831Z">
        <seg>마찬가지로 스테이징에에는 아직 프로덕션 환경에 배포되지 않는 커밋이 포함되어있을 수도 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>there is a tendency for config files to be scattered about in different places and different formats, making it hard to see and manage all the config in one place.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T170240Z" creationid="nacyot" creationdate="20140517T170240Z">
        <seg>또한 설정파일이 서로 다른 장소에 서로 다른 포맷으로 저장될 가능성이 있어 설정을 같은 곳에서 일괄적으로 관리하기 어려워진다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>two MySQL databases (used for sharding at the application layer) qualify as two distinct resources.</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T163151Z" creationid="nacyot" creationdate="20140517T163151Z">
        <seg>두 개의 Mysql 데이터베이스들은(어플리케이션 레이어에서 샤딩으로 사용) 두개의 다른 리소스라고 할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>unlike config files, there is little chance of them being checked into the code repo accidentally;</seg>
      </tuv>
      <tuv lang="KO" changeid="nacyot" changedate="20140517T170530Z" creationid="nacyot" creationdate="20140517T170530Z">
        <seg>설정 파일과는 달리 저장소에 실수로 포함시킬 가능성도 거의 없다.</seg>
      </tuv>
    </tu>
<!-- Alternative translations -->
  </body>
</tmx>
